<html>
    <head>
        <title>helloword!</title>
        <script type="text/javascript">
        // 创建重复对象重复工作量太大
        var obj = {
            name:"悟空",
            age:19,
            sayName:function(){
             alert(name);
            }
        }
        var obj = {
            name:"八戒",
            age:20,
            sayName:function(){
             alert(name);
            }
        }

        /**
         * 使用工厂方式创建对象
         * 通过该方法可以大批量地创建对象 
         * 使用工厂函数创建的对象，使用的构造函数都是Object
         * 所以创建的对象都是Object这个类型。
         * 就导致我们无法区分出多种不同类型的对象
         */
        function creatPerson(name, age, gender){
            var obj = new Object();
            obj.name = name;
            obj.age = age;
            obj.gender = gender;
            return obj;
        }

        var obj1 = creatPerson("猪八戒",19,"男");
        console.log(obj1);

        /**
         * 构造函数 
         * 构造函数就是一个普通的函数，创建方式与普通函数没有区别
         * 不同的是构造函数习惯上首字母大写
         * 
         * 构造函数的执行流程：
         *  1. 立刻创建一个新的对象
         *  2. 将新建的对象设置为函数中的this
         *  3. 逐行执行函数中代码
         *  4. 将新建的对象作为返回值返回
         * 
         * 使用同一个构造函数创建的对象，我们称为一类对象，也将构造函数称作类
         *  我们将一个构造函数构造的对象就叫做类的实例。
         * 
         */

         function Person(name, age, gender){
            this.name = "孙悟空";
        }
        // 当使用Person()调用函数时， this.name是指window.name
        var per = Person();
        console.log(per);       // undefined
        console.log(window.name); //孙悟空

        // 当使用new Person() 调用函数时，this.name指的是obj的name
        var obj = new Person();
        console.log(obj);       // object
        console.log(obj.name);  // "孙悟空"


        // 完整的构造函数举例：
        function Dog(name, age, gender){
            var obj = new Object();
            this.name = name;
            this.age = age;
            this.gender = gender;
        }

        /**
         * 使用可以检查一个对象是否是一个类的实例
         */
        var dog1 = new Dog();
        console.log(dog1 instanceof Dog); // true

        /**
         * 所有的对象都是Object的后代
         * 所有的对象与Object做instanceof运算都是true 
         */
        console.log(dog1 instanceof Object);// true

        /**
         *  创建一个Person2的构造函数
         *      - 在Person2构造函数中，每一个对象都添加一个sayName方法
         *          目前我们的方法是在构造函数内部创建的，
         *          也就是说每执行一次构造函数，就会执行一次sayName方法
         *          所有实例的sayName方法是唯一的
         *          这样也就导致了构造函数执行一次就创建一个新的方法，执行100000次就创建这么多个方法。
         */

        function Person2(name, age, gender){
            var obj = new Object();
            this.name = name;
            this.age = age;
            this.gender = gender;
            this.sayName = function(){
                document.write("hello, I am " + this.name);
            }
        }

        var p1 = new Person2(1,2,"男");
        var p2 = new Person2(4,5,"女");

        console.log(p1.sayName == p2.sayName); //false
        // 将我们的方法提到构造函数外面
        function Person3(name, age, gender){
            var obj = new Object();
            this.name = name;
            this.age = age;
            this.gender = gender;
            this.sayName = f3
        }
        //但是将函数定义在全局作用域，污染了全局作用域的命名空间
        function f3(){
                document.write("hello, I am " + this.name);
        }
        var p1 = new Person2(1,2,"男");
        var p2 = new Person2(4,5,"女");
        console.log(p1.sayName == p2.sayName); //true


        /**
         * 原型prototype
         *  我们所创建的每一个函数，解析器都会向函数中添加一个属性：prototype
         */
        
        </script>
    </head>
    <body>
    </body>
</html>